//instrument.lib - Faust function of various types usefull for building physical model instruments 

declare name "Faust Instument Tools Library";
declare author "Romain Michon (rmichon@ccrma.stanford.edu)";
declare copyright "Romain Michon";
declare version "1.0";
declare licence "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license);

import("math.lib");
import("filter.lib");

//========================= ENVELOPE GENERATORS ===============================

//----------------------- VIBRATO ENVELOPE ----------------------------

// Vibrato envelope with 4 phases : 
//		- beginning : hold 0 for b seconds
//		- attack : a in seconds
//		- sustain : s is a percentage of the amplitude to be modified
//		- release : r in seconds
//USAGE : sig * env_vibr(b,a,s,r,t) ; t is the trigger signal

envVibrato(b,a,s,r,t) = env ~ (_,_,_) : (!,!,_) // the 3 'state' signals are fed back
with {
    env (p2,cnt,y) =
        (t>0) & (p2|(y>=1)), // p2 = decay-sustain phase
		(cnt + 1)*(t>0), // counter for the first step "b" 
        (y + p1*p3*u*(s/100) - p4*w*y)*((p4==0)|(y>=eps))	// y  = envelop signal
		//*(y>=eps) // cut off tails to prevent denormals
    with {
	p1 = (p2==0) & (t>0) & (y<1) & (cnt>(b*SR)); // p1 = attack phase
	p3 = 1-(cnt<(nb)); // p3 = beginning phase
	p4 = (t<=0) & (y>0);  // p4 = release phase
	// #samples in attack, decay, release, must be >0
	nb = SR*b+(b==0.0) ; na = SR*a+(a==0.0); nr = SR*r+(r==0.0);
	// attack and (-60dB) release rates
	z = s+(s==0.0)*db2linear(-60);
	u = 1/na; w = 1-1/pow(z*db2linear(60), 1/nr);
	// values below this threshold are considered zero in the release phase
	eps = db2linear(-120);
    };
};

//----------------------- ATTACK - SUSTAIN - RELEASE ----------------------------

// Envelope with 3 phases :
//		- attack : a in seconds
//		- sustain : s is a percentage of the amplitude to be modified
//		- release : r in seconds
//USAGE : sig * asr(a,s,r,t) ; t is the trigger signal

asr(a,s,r,t) = env ~ (_,_) : (!,_) // the 2 'state' signals are fed back
with {
    env (p2,y) =
        (t>0) & (p2|(y>=1)), // p2 = decay-sustain phase
        (y + p1*u*(s/100) - p3*w*y)	// y  = envelop signal
	*((p3==0)|(y>=eps)) // cut off tails to prevent denormals
    with {
	p1 = (p2==0) & (t>0) & (y<1); // p1 = attack phase
	p3 = (t<=0) & (y>0); // p3 = release phase
	// #samples in attack, decay, release, must be >0
	na = SR*a+(a==0.0); nr = SR*r+(r==0.0);
	// correct zero sustain level
	z = s+(s==0.0)*db2linear(-60);
	// attack, decay and (-60dB) release rates
	u = 1/na; w = 1-1/pow(z*db2linear(60), 1/nr);
	// values below this threshold are considered zero in the release phase
	eps = db2linear(-120);
    };
};

//========================= TABLES ===============================

//----------------------- TOOLS ----------------------------

saturationPos(x) = x<: (_>1),(_<=1 : _*x) :> _+_;
saturationNeg(x) = x<: (_<-1),(_>=-1 : _*x) :> _*-1+_;

//----------------------- BOW TABLE ----------------------------

bow(offset,slope) = pow(abs(sample) + 0.75, -4) : saturationPos
	with{
	sample(y) = (y + offset)*slope;
	};

//----------------------- REED TABLE ----------------------------
	
reed(offset,slope) = reedTable : saturationPos : saturationNeg
	with{
	reedTable = offset + (slope*_);
	};

//========================= FILTERS ===============================

//----------------------- ONE POLE ----------------------------

onePole(b0,a1,x) = (b0*x - a1*_)~_;

//----------------------- POLE ZERO ----------------------------

poleZero(b0,b1,a1,x) = (b0*x + b1*x' - a1*_)~_;

//----------------------- ONE ZEROS ----------------------------

oneZero0(b0,b1,x) = (_*b1 + x*b0)~_;

oneZero1(b0,b1,x) = (x'*b1 + x*b0);

//----------------------- BANDPASS FILTER WITH CONSTANT UNITY PEAK GAIN BASED ON A BIQUAD ----------------------------

bandPass(resonance,radius) = TF2(b0,b1,b2,a1,a2)
	with{
		a2 = radius*radius;
		a1 = -2*radius*cos(PI*2*resonance/SR);
		b0 = 0.5-0.5*a2;
		b1 = 0;
		b2 = -b0;
	};

//----------------------- BANDPASS FILTER BASED ON A BIQUAD ----------------------------

bandPassH(resonance,radius) = TF2(b0,b1,b2,a1,a2)
	with{
		a2 = radius*radius;
		a1 = -2*radius*cos(PI*2*resonance/SR);
		b0 = 1;
		b1 = 0;
		b2 = 0;
	};

//----------------------- FLUE JET NON-LINEAR FUNCTION ----------------------------	
// Jet Table: flue jet non-linear function, computed by a polynomial calculation
	
jetTable(x) = x <: _*(_*_-1) : saturationPos : saturationNeg;
	
//========================= WAVE TABLES ===============================

//----------------------- STICK IMPACT ----------------------------

readMarmstk1 = ffunction(float readMarmstk1 (int), <instrument.h>,"");
marmstk1TableSize = 246;

//----------------------- VOICE IMPULSE ----------------------------

readImpuls20 = ffunction(float readImpuls20(int), <instrument.h>,"");
impuls20TableSize = 256;
